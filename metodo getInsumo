private File getInsumo(String fullName, List<MultipartFile> files) throws IOException {
    long timerInicio = System.currentTimeMillis();
    File fileSearch = null;

    if (!StringUtils.hasLength(fullName) || files == null || files.isEmpty()) {
        return null;
    }

    Optional<MultipartFile> multFind = files.stream()
            .filter(f -> f.getOriginalFilename() != null && f.getOriginalFilename().endsWith(fullName))
            .findFirst();

    if (multFind.isPresent()) {
        MultipartFile targetFile = multFind.get();

        // Directorio base seguro
        Path uploadDir = Paths.get(UPLOAD_DIRECTORY).toAbsolutePath().normalize();

        // Paths seguros
        Path pathSource = uploadDir.resolve(targetFile.getOriginalFilename()).normalize();
        Path pathDest = uploadDir.resolve(fullName).normalize();

        // Validar que ambos paths est√©n dentro del directorio seguro
        if (!pathSource.startsWith(uploadDir) || !pathDest.startsWith(uploadDir)) {
            throw new SecurityException("Intento de Path Traversal detectado.");
        }

        // Eliminar archivos antiguos si existen
        Files.deleteIfExists(pathSource);
        Files.deleteIfExists(pathDest);

        // Guardar el archivo del MultipartFile
        try (var inputStream = targetFile.getInputStream()) {
            Files.copy(inputStream, pathDest, StandardCopyOption.REPLACE_EXISTING);
        }

        fileSearch = pathDest.toFile();

        long timerOutput = System.currentTimeMillis() - timerInicio;
        String strTimer = ReconProcessServiceImpl.getDuration(timerOutput);
        logger.info("TIMER: DOWNLOAD: {} : {}", fileSearch.getAbsolutePath(), strTimer);
    }

    return fileSearch;
}
